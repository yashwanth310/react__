{"ast":null,"code":"import { isDragActive } from '../drag/state/is-active.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n  return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(targetOrSelector, onPressStart, options = {}) {\n  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\n  const startPress = startEvent => {\n    const target = startEvent.currentTarget;\n    if (!target || !isValidPressEvent(startEvent) || isPressing.has(target)) return;\n    isPressing.add(target);\n    if (target.setPointerCapture && startEvent.pointerId !== undefined) {\n      try {\n        target.setPointerCapture(startEvent.pointerId);\n      } catch (e) {}\n    }\n    const onPressEnd = onPressStart(target, startEvent);\n    const onPointerEnd = (endEvent, success) => {\n      target.removeEventListener(\"pointerup\", onPointerUp);\n      target.removeEventListener(\"pointercancel\", onPointerCancel);\n      if (target.releasePointerCapture && endEvent.pointerId !== undefined) {\n        try {\n          target.releasePointerCapture(endEvent.pointerId);\n        } catch (e) {}\n      }\n      if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {\n        return;\n      }\n      isPressing.delete(target);\n      if (typeof onPressEnd === \"function\") {\n        onPressEnd(endEvent, {\n          success\n        });\n      }\n    };\n    const onPointerUp = upEvent => {\n      const isOutside = !upEvent.isTrusted ? false : checkOutside(upEvent, target instanceof Element ? target.getBoundingClientRect() : {\n        left: 0,\n        top: 0,\n        right: window.innerWidth,\n        bottom: window.innerHeight\n      });\n      if (isOutside) {\n        onPointerEnd(upEvent, false);\n      } else {\n        onPointerEnd(upEvent, !(target instanceof Element) || isNodeOrChild(target, upEvent.target));\n      }\n    };\n    const onPointerCancel = cancelEvent => {\n      onPointerEnd(cancelEvent, false);\n    };\n    target.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n    target.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n    target.addEventListener(\"lostpointercapture\", onPointerCancel, eventOptions);\n  };\n  targets.forEach(target => {\n    target = options.useGlobalTarget ? window : target;\n    let canAddKeyboardAccessibility = false;\n    if (target instanceof HTMLElement) {\n      canAddKeyboardAccessibility = true;\n      if (!isElementKeyboardAccessible(target) && target.getAttribute(\"tabindex\") === null) {\n        target.tabIndex = 0;\n      }\n    }\n    target.addEventListener(\"pointerdown\", startPress, eventOptions);\n    if (canAddKeyboardAccessibility) {\n      target.addEventListener(\"focus\", event => enableKeyboardPress(event, eventOptions), eventOptions);\n    }\n  });\n  return cancelEvents;\n}\nfunction checkOutside(event, rect) {\n  return event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom;\n}\nexport { press };","map":{"version":3,"names":["isDragActive","isNodeOrChild","isPrimaryPointer","setupGesture","isElementKeyboardAccessible","enableKeyboardPress","isPressing","isValidPressEvent","event","press","targetOrSelector","onPressStart","options","targets","eventOptions","cancelEvents","startPress","startEvent","target","currentTarget","has","add","setPointerCapture","pointerId","undefined","e","onPressEnd","onPointerEnd","endEvent","success","removeEventListener","onPointerUp","onPointerCancel","releasePointerCapture","delete","upEvent","isOutside","isTrusted","checkOutside","Element","getBoundingClientRect","left","top","right","window","innerWidth","bottom","innerHeight","cancelEvent","addEventListener","forEach","useGlobalTarget","canAddKeyboardAccessibility","HTMLElement","getAttribute","tabIndex","rect","clientX","clientY"],"sources":["C:/Users/koush/Documents/YASHU/react-assignment/node_modules/motion-dom/dist/es/gestures/press/index.mjs"],"sourcesContent":["import { isDragActive } from '../drag/state/is-active.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(targetOrSelector, onPressStart, options = {}) {\n    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\n    const startPress = (startEvent) => {\n        const target = startEvent.currentTarget;\n        if (!target || !isValidPressEvent(startEvent) || isPressing.has(target))\n            return;\n        isPressing.add(target);\n        if (target.setPointerCapture && startEvent.pointerId !== undefined) {\n            try {\n                target.setPointerCapture(startEvent.pointerId);\n            }\n            catch (e) { }\n        }\n        const onPressEnd = onPressStart(target, startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            target.removeEventListener(\"pointerup\", onPointerUp);\n            target.removeEventListener(\"pointercancel\", onPointerCancel);\n            if (target.releasePointerCapture &&\n                endEvent.pointerId !== undefined) {\n                try {\n                    target.releasePointerCapture(endEvent.pointerId);\n                }\n                catch (e) { }\n            }\n            if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {\n                return;\n            }\n            isPressing.delete(target);\n            if (typeof onPressEnd === \"function\") {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            const isOutside = !upEvent.isTrusted\n                ? false\n                : checkOutside(upEvent, target instanceof Element\n                    ? target.getBoundingClientRect()\n                    : {\n                        left: 0,\n                        top: 0,\n                        right: window.innerWidth,\n                        bottom: window.innerHeight,\n                    });\n            if (isOutside) {\n                onPointerEnd(upEvent, false);\n            }\n            else {\n                onPointerEnd(upEvent, !(target instanceof Element) ||\n                    isNodeOrChild(target, upEvent.target));\n            }\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        target.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n        target.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n        target.addEventListener(\"lostpointercapture\", onPointerCancel, eventOptions);\n    };\n    targets.forEach((target) => {\n        target = options.useGlobalTarget ? window : target;\n        let canAddKeyboardAccessibility = false;\n        if (target instanceof HTMLElement) {\n            canAddKeyboardAccessibility = true;\n            if (!isElementKeyboardAccessible(target) &&\n                target.getAttribute(\"tabindex\") === null) {\n                target.tabIndex = 0;\n            }\n        }\n        target.addEventListener(\"pointerdown\", startPress, eventOptions);\n        if (canAddKeyboardAccessibility) {\n            target.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\n        }\n    });\n    return cancelEvents;\n}\nfunction checkOutside(event, rect) {\n    return (event.clientX < rect.left ||\n        event.clientX > rect.right ||\n        event.clientY < rect.top ||\n        event.clientY > rect.bottom);\n}\n\nexport { press };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}